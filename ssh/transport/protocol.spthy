theory ssh_transport

/*
 * Status: Not working
 */

begin

builtins: hashing, signing, diffie-hellman, symmetric-encryption
functions: mac/2

/*******************/
/* Secure channels */
/*******************/

rule Out_C_to_S:
    [ Out_to_S(idC, x) ]
    --[ Out_C_to_S(idC, x) ]->
    [ !Secure_from_C(idC,x) ]

rule In_C_to_S:
    [ !Secure_from_C(idC, x) ]
    --[ In_C_to_S(idC, x) ]->
    [ In_from_C(idC, x) ]

rule Out_S_to_C:
    [ Out_to_C(idS, x) ]
    --[ Out_S_to_C(idS, x) ]->
    [ !Secure_from_S(idS,x) ]

rule In_S_to_C:
    [ !Secure_from_S(idS, x) ]
    --[ In_S_to_C(idS, x) ]->
    [ In_from_S(idS, x) ]

/************/
/* Protocol */
/************/

// NOTICE: as this is a simplified version, it is assumed that we 
// are using an authenticated DH exchange, symmetric encryption, mac algorithm and no compression

rule Init:
    [ Fr(~S_sign_key)                           // Sign key of the server
    , Fr(~idS)                                  // Id of the server
    , Fr(~idC)                                  // Id of the client
    ]
    -->
    [ CState(~idC, 'INIT', <pk(~S_sign_key)>)
    , SState(~idS, 'INIT', <~S_sign_key>)
    , Out(pk(~S_sign_key))                      // Make sure the sign verification key of the server is public
    ]

rule C_1:
    let
        pubC = 'g'^~secretC                                     // Public DH half-key
    in
    [ CState(~idC, 'INIT', <S_pubkey>) 
    , Fr(~secretC)                                              // Generate fresh secret DH parameter
    ]
    --[ CSentDHParam(~idC, pubC) ]->
    [ Out(<'KEXDHINIT', pubC>)                                  // Send request to server 
    , CState(~idC, 'SENT_DH_PARAM', <S_pubkey, ~secretC>)
    ]

rule S_1:
    let 
        S_pubkey = pk(~S_sign_key)
        pubS = 'g'^~secretS
        key = pubC^~secretS
        hashed = h(<S_pubkey, pubC, pubS, key>)
        
        // Derive secrets from master key
        enc_key_C_to_S = h(<key, hashed, 'enc_key_C_to_S'>)
        enc_key_S_to_C = h(<key, hashed, 'enc_key_S_to_C'>)
        mac_key_C_to_S = h(<key, hashed, 'mac_key_C_to_S'>)
        mac_key_S_to_C = h(<key, hashed, 'mac_key_S_to_C'>)
        derived_keys = <enc_key_C_to_S, enc_key_S_to_C, mac_key_C_to_S, mac_key_S_to_C>
    in
    [ SState(~idS, 'INIT', <~S_sign_key>)
    , In(<'KEXDHINIT', pubC>)
    , Fr(~secretS)
    ]
  --[ SSentDHParam(~idS, pubS)
    , SInstallsKey(~idS, key)
    ]->
    [ Out(<'KEXDHREPLY', S_pubkey, pubS, sign(hashed, ~S_sign_key)>)
    , !SFinalState(~idS, 'KEY_INSTALLED', <~S_sign_key, ~secretS, key, derived_keys>)
    ]

rule C_2:
    let 
        pubC = 'g'^~secretC
        key = pubS^~secretC
        hashed = h(<S_pubkey, pubC, pubS, key>)
        enc_key_C_to_S = h(<key, hashed, 'enc_key_C_to_S'>)
        enc_key_S_to_C = h(<key, hashed, 'enc_key_S_to_C'>)
        mac_key_C_to_S = h(<key, hashed, 'mac_key_C_to_S'>)
        mac_key_S_to_C = h(<key, hashed, 'mac_key_S_to_C'>)
        derived_keys = <enc_key_C_to_S, enc_key_S_to_C, mac_key_C_to_S, mac_key_S_to_C>
    in
    [ CState(~idC, 'SENT_DH_PARAM', <S_pubkey, ~secretC>)
    , In(<'KEXDHREPLY', S_pubkey, pubS, signature>)
    , Fr(~client_secret)
    ]
  --[ Equal(verify(signature, hashed, S_pubkey), true)
    , CInstallsKey(~idC, key)
    , CSendsClientSecretToServer(~idC, ~client_secret)
    ]->
    [ Out_to_S(~idC, ~client_secret)
    , !CFinalState(~idC, 'KEY_INSTALLED', <S_pubkey, ~secretC, key, derived_keys>)
    ] 

/*
rule S_3_1:
    let
        derived_keys = <enc_key_C_to_S, enc_key_S_to_C, mac_key_C_to_S, mac_key_S_to_C>
    in
    [ !SFinalState(~idS, 'KEY_INSTALLED', <~S_sign_key, ~secretS, key, derived_keys>)
    , In_from_C(idC, m3payload)
    ]
    --[]->
    [ Out(<senc(m3payload, enc_key_S_to_C), mac(m3payload, mac_key_S_to_C)>) ]

rule S_3_2:
    let
        derived_keys = <enc_key_C_to_S, enc_key_S_to_C, mac_key_C_to_S, mac_key_S_to_C>
    in
    [ !SFinalState(~idS, 'KEY_INSTALLED', <~S_sign_key, ~secretS, key, derived_keys>)
    , In(<senc(m2payload, enc_key_C_to_S), mac(m2payload, mac_key_C_to_S)>)
    ]
    --[]->
    [ Out_to_C(~idS, m2payload) ]

rule C_3_1:
    let
        derived_keys = <enc_key_C_to_S, enc_key_S_to_C, mac_key_C_to_S, mac_key_S_to_C>
    in
    [ !CFinalState(~idC, 'KEY_INSTALLED', <S_pubkey, ~secretC, key, derived_keys>)
    , In_from_S(idS, m2payload)
    ]
    --[]->
    [ Out(<senc(m2payload, enc_key_C_to_S), mac(m2payload, mac_key_C_to_S)>) ]

rule C_3_2:
    let
        derived_keys = <enc_key_C_to_S, enc_key_S_to_C, mac_key_C_to_S, mac_key_S_to_C>
    in
    [ !CFinalState(~idC, 'KEY_INSTALLED', <S_pubkey, ~secretC, key, derived_keys>)
    , In(<senc(m4payload, enc_key_S_to_C), mac(m4payload, mac_key_S_to_C)>)
    ]
    --[]->
    [ Out_to_S(~idC, m4payload) ]
*/

restriction Equal:
    "
    All x y #NOW. Equal(x, y) @NOW ==> x = y
    "

/*******************/
/* Security lemmas */
/*******************/

// Does NOT terminate (may also be incorrect)
lemma secret:
    "
    All idC secret #i.
    CSendsClientSecretToServer(idC, secret) @i
    ==>
    not(
      Ex #k. K(secret) @k
    )
    "

// Does NOT terminate (may also be incorrect)
lemma executable:
    exists-trace
    "
    Ex idS idC key secret #i #j #s.
    SInstallsKey(idS, key) @i
    & CInstallsKey(idC, key) @j
    & CSendsClientSecretToServer(idC, secret) @s
    "

end
